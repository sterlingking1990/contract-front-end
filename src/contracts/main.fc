#include "imports/stdlib.fc";

;;define amount to keep
const const::min_tons_for_storage = 10000000; ;;0.01 TON

(int, slice, slice) load_data() inline {
    var ds = get_data().begin_parse();
    return (ds~load_uint(32),ds~load_msg_addr(),ds~load_msg_addr());
}

() save_data(int counter_value, slice recent_sender, slice owner_address) impure inline {
    set_data(begin_cell()
        .store_uint(counter_value,32)
        .store_slice(recent_sender)
        .store_slice(owner_address)
        .end_cell());
}

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
    
    slice cs = in_msg.begin_parse();

    int flags = cs~load_uint(4);

    slice sender_address = cs~load_msg_addr();

    ;;Ensure the in_msg_body has at least 32 bits before loading the operation code
    int op = in_msg_body~load_uint(32);

    var (counter_value, recent_sender, owner_address) = load_data();

    ;;Check if the operation code is 1
    if (op == 1) {
        ;;get the increment by from the in message body
        ;;counter_val is preset on contract data store while set up
        int increment_by = in_msg_body~load_uint(32);
        ;;now we alter the state of the contract storage; we can use load_data to get back these stored state
        save_data(counter_value + increment_by, sender_address, owner_address);
        return();
    }

    if(op == 2){
        ;;deposit
        return();
    }

    if(op == 3){
        ;;withdraw
            
        throw_unless(103, equal_slice_bits(sender_address,owner_address));
        ;;amt to withdraw
        int withdraw_amount = in_msg_body~load_coins();
        var [balance, _] = get_balance();
        ;;throw err if trying to withdraw almost same amt in balance
        throw_unless(104, balance >= withdraw_amount);

        int return_value = min(withdraw_amount, balance - const::min_tons_for_storage);

        ;;sending internal message
        int msg_mode = 1; ;;0- ordinary msg, 1- pay transfer fees seperately

        var msg = begin_cell()
                .store_uint(0x18,6) ;;empty source
                .store_slice(sender_address) ;; destination add, since fund is withdrawn by sender to his sender wallet addr
                .store_coins(return_value)
                .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);
        send_raw_message(msg.end_cell(), msg_mode);

        return();
    }
    throw(777);
}

(int,slice,slice) get_contract_storage_data() method_id {
    var (counter_value,recent_sender,owner_address) = load_data();
    return (
        counter_value,
        recent_sender,
        owner_address
    );
}

int balance() method_id {
    var [balance,_] = get_balance();
    return balance;
}


